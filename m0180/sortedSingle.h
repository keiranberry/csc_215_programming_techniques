/** **************************************************************************
 * @file    
 *
 * @brief   The declaration of the singly linked list for a list that
 *          is sorted.
 ****************************************************************************/
#include <iostream>
#include <string>
using std::ostream;
using std::string;
using std::nothrow;
/*****************************************************************************
 * do not edit this file
 ****************************************************************************/

/** **************************************************************************
 * @class   sortedSingle
 *
 * @brief   A sorted singly linked list of integers.
 ****************************************************************************/
template <typename TY> 
class sortedSingle
{
    public:

    // do not write.
    sortedSingle( sortedSingle<TY> &l );

    // file sortedSinglea.cpp
    sortedSingle( );
    ~sortedSingle( );
    bool find( TY item );
    int retrievePosition( TY item );
    int size( );
    bool empty( );

    // file sortedSingleb.cpp
    bool insert( TY item );
    void print( ostream &out, string seperator = ", " );

    // file sortedSinglec.cpp
    bool remove( TY item );
    void clear( );

    void swap(sortedSingle<TY>& l);
    sortedSingle<TY>& operator=(sortedSingle<TY>& rhs);
    bool operator==(const sortedSingle<TY>& rhs) const;
    bool operator!=(const sortedSingle<TY>& rhs) const;

    template <class TY>
    friend ostream& operator<<(ostream& out, sortedSingle<TY>& l);

    private:

    /** 
     * @brief  the storage container for each item in the list 
     */
    struct node
    {

        TY theItem;    /*!< the item */
        node *next;     /*!< pointer to the remaining nodes in list */
    };
    node *headptr;      /*!< The location of the first node in the list */
};



template<typename TY> 
sortedSingle<TY>::sortedSingle()
{
    headptr = nullptr;
}



template<typename TY> 
sortedSingle<TY>::~sortedSingle()
{
    node* temp;
    
    while (headptr != nullptr)
    {
        temp = headptr;
        headptr = temp->next;
        delete temp;
    }
}



template<typename TY>
bool sortedSingle<TY>::empty()
{
    if (headptr == nullptr)
    {
        return true;
    }

    return false;
}


template<typename TY>
int sortedSingle<TY>::size()
{
    node* temp = nullptr;
    temp = headptr;
    int count;

    if (headptr == nullptr)
    {
        return 0;
    }

    for (count = 1; temp->next != nullptr; count++)
    {
        temp = temp->next;
    }

    return count;
}


template<typename TY>
bool sortedSingle<TY>::find(TY item)
{
    node* temp = nullptr;
    temp = headptr;
    bool found = false;

    while (temp != nullptr)
    {
        if (temp->theItem == item)
        {
            found = true;
        }
        temp = temp->next;
    }

    return found;
}


template<typename TY>
int sortedSingle<TY>::retrievePosition(TY item)
{
    node* temp = nullptr;
    temp = headptr;
    int where = 1;

    while (temp != nullptr)
    {
        if (temp->theItem == item)
        {
            return where;
        }
        temp = temp->next;
        where++;
    }

    return 0;
}


template<typename TY>
bool sortedSingle<TY>::insert(TY item)
{
    node* current = headptr;
    node* previous = nullptr;
    node* temp = new (nothrow) node;

    if (temp == nullptr)
    {
        return false;
    }

    temp->theItem = item;
    temp->next = nullptr;

    if (headptr == nullptr)
    {
        headptr = temp;
        return true;
    }

    while (current != nullptr && item > current->theItem)
    {
        previous = current;
        current = current->next;
    }

    if (previous == nullptr)
    {
        temp->next = current;
        headptr = temp;
        return true;
    }

    temp->next = current;
    previous->next = temp;
    return true;
}


template<typename TY>
void sortedSingle<TY>::print(ostream& out, string seperator)
{
    node* temp = nullptr;
    temp = headptr;

    while (temp != nullptr)
    {
        out << temp->theItem;
        if (temp->next != nullptr)
        {
            out << seperator;
        }
        temp = temp->next;
    }
}


template<typename TY>
bool sortedSingle<TY>::remove(TY item)
{
    node* previous;
    node* current = headptr;
    previous = current;

    if (headptr == nullptr)
    {
        return false;
    }

    while (current != nullptr)
    {
        if (current->theItem == item)
        {
            if (previous == headptr)
            {
                headptr = current->next;
                delete current;
                return true;
            }
            previous->next = current->next;
            delete current;
            return true;
        }
        previous = current;
        current = current->next;

    }
    return false;
}



template<typename TY>
void sortedSingle<TY>::clear()
{
    node* temp;

    while (headptr != nullptr)
    {
        temp = headptr;
        headptr = temp->next;
        delete temp;
    }
}


template<typename TY>
sortedSingle<TY>::sortedSingle(sortedSingle<TY>& l)
{
    node* source;
    node* destination;

    if (l.headptr == nullptr)
    {
        headptr = nullptr;
        return;
    }

    headptr = new (nothrow) node;
    headptr->theItem = l.headptr->theItem;
    headptr->next = nullptr;

    source = l.headptr->next;
    destination = headptr;

    while (source != nullptr)
    {
        destination->next = new(nothrow) node;
        destination = destination->next;
        destination->theItem = source->theItem;
        destination->next = nullptr;
        source = source->next;
    }

    return;
}

template <typename TY>
void sortedSingle<TY>::swap(sortedSingle<TY>& l)
{
    node* temp;
    temp = l.headptr;
    l.headptr = headptr;
    headptr = temp;
}

template <typename TY>
sortedSingle<TY>& sortedSingle<TY>::operator=(sortedSingle<TY>& rhs)
{
    node* step;

    step = rhs.headptr;

    while (step != nullptr)
    {
        if (find(step->theItem) == false)
        {
            insert(step->theItem);
        }
        step = step->next;
    }

    return rhs;
}

template <typename TY>
bool sortedSingle<TY>::operator==(const sortedSingle<TY>& rhs) const
{
    node* one;
    node* two;

    one = headptr;
    two = rhs.headptr;

    while (one != nullptr && two != nullptr)
    {
        if (one->theItem != two->theItem)
        {
            return false;
        }

        one = one->next;
        two = two->next;
    }

    if (one == nullptr && two == nullptr)
    {
        return true;
    }

    return false;
}

template <typename TY>
bool sortedSingle<TY>::operator!=(const sortedSingle<TY>& rhs) const
{
    node* one;
    node* two;

    one = headptr;
    two = rhs.headptr;

    while (one != nullptr && two != nullptr)
    {
        if (one->theItem != two->theItem)
        {
            return true;
        }

        one = one->next;
        two = two->next;
    }

    if (one == nullptr && two == nullptr)
    {
        return false;
    }

    return true;
}

template <class TY>
ostream& operator<<(ostream& out, sortedSingle<TY>& l)
{
    auto temp = l.headptr;
    int i = 0;
    while (temp != nullptr)
    {
        out << temp->theItem;
        if (i < l.size()-1)
        {
            out << " ";
        }
        temp = temp->next;
        i++;
    }

    return out;
}